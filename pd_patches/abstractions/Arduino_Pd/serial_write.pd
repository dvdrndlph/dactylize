#N canvas 446 254 732 457 10;
#X obj 30 102 inlet;
#X obj 30 353 outlet;
#X text 29 386 Written by Alexandros Drymonitis;
#N canvas 526 271 636 354 repack 0;
#X obj 36 27 inlet;
#X obj 36 49 route float bang;
#X obj 36 156 + 1;
#X obj 93 206 t l l;
#X obj 93 184 list prepend;
#X obj 36 180 sel;
#X obj 271 216 inlet data_amount;
#X obj 68 250 outlet;
#X obj 36 71 t b f;
#X obj 68 228 list;
#X obj 206 214 sel 0 1;
#X obj 271 239 route 0 1;
#X obj 206 256 f;
#X obj 229 280 f;
#X text 336 237 these are the two groups of values;
#X obj 36 202 t b b;
#X obj 36 133 f;
#X obj 234 169 0;
#X obj 206 169 1;
#X obj 90 116 0;
#X obj 90 93 t b b;
#X obj 90 71 t b b;
#X obj 156 152 t b b;
#X connect 0 0 1 0;
#X connect 1 0 8 0;
#X connect 1 1 21 0;
#X connect 2 0 16 1;
#X connect 2 0 5 0;
#X connect 3 0 9 1;
#X connect 3 1 4 1;
#X connect 4 0 3 0;
#X connect 5 0 15 0;
#X connect 6 0 11 0;
#X connect 8 0 16 0;
#X connect 8 1 4 0;
#X connect 9 0 7 0;
#X connect 10 0 12 0;
#X connect 10 1 13 0;
#X connect 11 0 12 1;
#X connect 11 1 13 1;
#X connect 12 0 5 1;
#X connect 13 0 5 1;
#X connect 15 0 22 0;
#X connect 15 1 9 0;
#X connect 16 0 2 0;
#X connect 17 0 10 0;
#X connect 18 0 10 0;
#X connect 19 0 16 1;
#X connect 20 0 19 0;
#X connect 20 1 4 1;
#X connect 21 0 20 0;
#X connect 21 1 17 0;
#X connect 22 0 20 0;
#X connect 22 1 18 0;
#X restore 30 232 pd repack;
#X obj 227 295 outlet;
#X obj 466 191 inlet change_num_of_data;
#X obj 269 191 t f f;
#N canvas 454 255 874 377 \$0-route_list 0;
#X obj 31 248 f;
#X obj 61 248 == 0;
#X obj 31 48 t b l;
#X obj 31 26 inlet;
#X obj 31 271 list append;
#X obj 31 317 outlet;
#X obj 147 317 outlet;
#X obj 147 273 inlet which_is_analog;
#N canvas 660 323 450 300 specify_analog 0;
#X obj 55 130 t l l;
#X obj 55 173 spigot;
#X obj 105 173 spigot;
#X obj 205 130 t l l;
#X obj 205 173 spigot;
#X obj 255 173 spigot;
#N canvas 511 257 426 339 assemble_analog 0;
#X obj 38 81 list split 2;
#X obj 51 106 list;
#X obj 144 151 unpack;
#X obj 144 190 +;
#X obj 183 173 * 128;
#X obj 38 56 inlet bytes;
#X obj 119 280 outlet;
#X obj 144 213 list prepend;
#X obj 144 235 t l l;
#X obj 38 134 t b l;
#X obj 119 257 list;
#X obj 119 104 t b b;
#X text 36 10 this used to be the [read_analog_pins] abstraction \,
which is now integrated in the [serial_write] abstraction.;
#X connect 0 0 9 0;
#X connect 0 1 1 1;
#X connect 0 2 11 0;
#X connect 1 0 0 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 3 0 7 0;
#X connect 4 0 3 1;
#X connect 5 0 0 0;
#X connect 7 0 8 0;
#X connect 8 0 10 1;
#X connect 8 1 7 1;
#X connect 9 0 1 0;
#X connect 9 1 2 0;
#X connect 10 0 6 0;
#X connect 11 0 10 0;
#X connect 11 1 7 1;
#X restore 105 203 pd assemble_analog;
#N canvas 511 257 426 339 assemble_analog 0;
#X obj 38 81 list split 2;
#X obj 51 106 list;
#X obj 144 151 unpack;
#X obj 144 190 +;
#X obj 183 173 * 128;
#X obj 38 56 inlet bytes;
#X obj 119 280 outlet;
#X obj 144 213 list prepend;
#X obj 144 235 t l l;
#X obj 38 134 t b l;
#X obj 119 257 list;
#X obj 119 104 t b b;
#X text 36 10 this used to be the [read_analog_pins] abstraction \,
which is now integrated in the [serial_write] abstraction.;
#X connect 0 0 9 0;
#X connect 0 1 1 1;
#X connect 0 2 11 0;
#X connect 1 0 0 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 3 0 7 0;
#X connect 4 0 3 1;
#X connect 5 0 0 0;
#X connect 7 0 8 0;
#X connect 8 0 10 1;
#X connect 8 1 7 1;
#X connect 9 0 1 0;
#X connect 9 1 2 0;
#X connect 10 0 6 0;
#X connect 11 0 10 0;
#X connect 11 1 7 1;
#X restore 255 203 pd assemble_analog;
#X obj 55 238 outlet;
#X obj 205 238 outlet;
#X obj 234 35 inlet which_is_analog;
#X obj 144 149 == 0;
#X obj 244 149 == 0;
#X obj 234 57 t f f f f;
#X obj 55 67 inlet;
#X obj 55 89 route 0 1;
#X connect 0 0 1 0;
#X connect 0 1 2 0;
#X connect 1 0 8 0;
#X connect 2 0 6 0;
#X connect 3 0 4 0;
#X connect 3 1 5 0;
#X connect 4 0 9 0;
#X connect 5 0 7 0;
#X connect 6 0 8 0;
#X connect 7 0 9 0;
#X connect 10 0 13 0;
#X connect 11 0 2 1;
#X connect 12 0 4 1;
#X connect 13 0 1 1;
#X connect 13 1 11 0;
#X connect 13 2 12 0;
#X connect 13 3 5 1;
#X connect 14 0 15 0;
#X connect 15 0 0 0;
#X connect 15 1 3 0;
#X restore 31 295 pd specify_analog;
#X text 85 19 if we don't provide a second argument \, use 1 to compare
[f] so that it always outputs 0 \, else use 0;
#X obj 86 50 r \$0-num_args;
#X obj 307 120 r \$0-arg_type;
#X obj 240 142 sel analog;
#X obj 240 97 r \$0-message_type;
#X obj 307 164 t b;
#X msg 307 231 0;
#X obj 307 209 spigot;
#X obj 86 74 t f f;
#X text 353 212 if we have already provided four arguments \, then
don't let the messages control whether we receive both analog and digital
values;
#X text 409 120 if we have provided two arguments only \, set the type
of argument to see if a message we send is of the same type \, so that
we don't change the alternating counter. if it's of the other type
\, we need the counter to alternate between 0 and 1;
#X connect 0 0 1 0;
#X connect 0 0 4 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 2 1 4 1;
#X connect 3 0 2 0;
#X connect 4 0 8 0;
#X connect 7 0 8 1;
#X connect 8 0 5 0;
#X connect 8 1 6 0;
#X connect 10 0 17 0;
#X connect 11 0 12 1;
#X connect 12 1 14 0;
#X connect 13 0 12 0;
#X connect 14 0 16 0;
#X connect 15 0 1 1;
#X connect 16 0 15 0;
#X connect 17 0 1 1;
#X connect 17 1 16 1;
#X restore 30 256 pd \$0-route_list;
#N canvas 407 270 799 340 \$0-change_num_of_data 0;
#X obj 12 44 inlet which_is_analog;
#X obj 175 67 route analog digital;
#X obj 175 158 f;
#X obj 221 141 t f f;
#X obj 233 163 f;
#X obj 175 180 pack;
#X obj 175 252 outlet;
#X obj 233 185 == 0;
#X obj 233 207 pack;
#X obj 175 20 inlet change_num_of_data;
#X obj 196 112 * 2;
#X obj 175 42 t a a;
#X obj 358 59 unpack s f;
#X obj 358 81 s \$0-message_type;
#X obj 175 89 t b f;
#X obj 233 89 t b f;
#X connect 0 0 3 0;
#X connect 1 0 14 0;
#X connect 1 1 15 0;
#X connect 2 0 5 0;
#X connect 3 0 2 1;
#X connect 3 1 4 1;
#X connect 4 0 7 0;
#X connect 5 0 6 0;
#X connect 7 0 8 0;
#X connect 8 0 6 0;
#X connect 9 0 11 0;
#X connect 10 0 5 1;
#X connect 11 0 1 0;
#X connect 11 1 12 0;
#X connect 12 0 13 0;
#X connect 14 0 2 0;
#X connect 14 1 10 0;
#X connect 15 0 4 0;
#X connect 15 1 8 1;
#X restore 301 215 pd \$0-change_num_of_data;
#N canvas 202 141 982 483 \$0-assemble_num_of_data 0;
#X obj 58 346 outlet;
#X obj 58 36 loadbang;
#X obj 58 91 t b b;
#X obj 107 129 sel analog digital;
#X msg 107 207 2;
#X msg 168 230 1;
#X obj 58 247 *;
#X obj 58 58 t b b;
#X obj 358 75 t b b;
#X obj 358 104 \$2;
#X obj 407 153 sel analog digital;
#X obj 407 92 symbol \$1;
#X msg 407 198 2;
#X msg 468 198 1;
#X obj 358 237 *;
#X obj 107 108 symbol \$3;
#X obj 58 113 \$4;
#X msg 358 264 0 \$1;
#X msg 58 269 1 \$1;
#X text 395 264 first group of values;
#X text 94 268 second group of values;
#X text 55 2 analog values are split in two \, so we receive two bytes
per value. digital values are being received as is.;
#X obj 407 175 t b b;
#X msg 510 192 0;
#X obj 107 184 t b b;
#X msg 195 201 1;
#X obj 510 346 outlet which_is_analog;
#X obj 244 168 s \$0-num_args;
#X msg 543 170 at least two arguments needed;
#X obj 407 114 t s s;
#X obj 471 131 s \$0-arg_type;
#X obj 543 192 print serial_write;
#X obj 468 220 t f f;
#X text 519 213 if first group is digital \, set which is analog \,
because we might not receive further arguments \, in case we use only
digital;
#X msg 244 146 1;
#X connect 1 0 7 0;
#X connect 2 0 16 0;
#X connect 2 1 15 0;
#X connect 3 0 24 0;
#X connect 3 1 5 0;
#X connect 3 2 34 0;
#X connect 4 0 6 1;
#X connect 5 0 6 1;
#X connect 6 0 18 0;
#X connect 7 0 2 0;
#X connect 7 1 8 0;
#X connect 8 0 9 0;
#X connect 8 1 11 0;
#X connect 9 0 14 0;
#X connect 10 0 22 0;
#X connect 10 1 13 0;
#X connect 10 2 28 0;
#X connect 11 0 29 0;
#X connect 12 0 14 1;
#X connect 13 0 32 0;
#X connect 14 0 17 0;
#X connect 15 0 3 0;
#X connect 16 0 6 0;
#X connect 17 0 0 0;
#X connect 18 0 0 0;
#X connect 22 0 12 0;
#X connect 22 1 23 0;
#X connect 23 0 26 0;
#X connect 24 0 4 0;
#X connect 24 1 25 0;
#X connect 25 0 26 0;
#X connect 28 0 31 0;
#X connect 29 0 10 0;
#X connect 29 1 30 0;
#X connect 32 0 14 1;
#X connect 32 1 26 0;
#X connect 34 0 27 0;
#X restore 90 167 pd \$0-assemble_num_of_data;
#N canvas 581 353 354 270 set_initializer 0;
#X obj 57 70 loadbang;
#X obj 57 92 \$5;
#X obj 57 114 sel 0;
#X msg 57 136 192;
#X obj 57 158 outlet;
#X obj 126 70 inlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 3 0 4 0;
#X connect 5 0 2 0;
#X restore 514 62 pd set_initializer;
#X obj 514 40 inlet;
#X obj 83 288 r \$0-num_args;
#X obj 30 305 spigot;
#X obj 30 330 list;
#X obj 30 278 t b l;
#X text 80 316 if we receive two arguments only \, force a bang when
the first package finishes;
#X obj 30 147 select;
#X obj 195 273 t b l;
#X obj 30 124 spigot;
#X obj 514 84 t b f;
#X msg 514 107 1;
#X text 27 9 This abstraction uses the technique found in the rePatcher
by Open Music Labs (slightly modified) \, to receive data from the
Arduino. It needs a unique byte to denote the beginning of the data
stream (which is 192 by default \, [sel]s' argument) after which \,
all bytes are being collected by [pd repack] and dumped as a list.
;
#X connect 0 0 19 0;
#X connect 3 0 7 0;
#X connect 5 0 8 1;
#X connect 6 0 7 1;
#X connect 6 1 8 0;
#X connect 7 0 15 0;
#X connect 7 1 18 0;
#X connect 8 0 3 1;
#X connect 9 0 3 1;
#X connect 9 1 6 0;
#X connect 10 0 20 0;
#X connect 11 0 10 0;
#X connect 12 0 13 1;
#X connect 13 0 14 0;
#X connect 14 0 1 0;
#X connect 15 0 13 0;
#X connect 15 1 14 1;
#X connect 17 0 3 0;
#X connect 17 1 3 0;
#X connect 18 0 14 0;
#X connect 18 1 4 0;
#X connect 19 0 17 0;
#X connect 20 0 21 0;
#X connect 20 1 17 1;
#X connect 21 0 19 1;
